/* *****************************************************************************
 * Copyright (c) 2013-2015 Qingtao Cao
 *
 * This file is part of oBIX.
 *
 * oBIX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * oBIX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with oBIX. If not, see <http://www.gnu.org/licenses/>.
 *
 * *****************************************************************************/

#include <libgen.h>			/* dirname */
#include <string.h>			/* memset */
#include <stdlib.h>			/* malloc */
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include "xml_storage.h"
#include "obix_utils.h"
#include "list.h"
#include "tsync.h"
#include "refcnt.h"
#include "hash.h"
#include "cache.h"
#include "watch.h"
#include "xml_utils.h"
#include "log_utils.h"
#include "security.h"
#include "errmsg.h"

static const char *SERVER_DB_DEVICES = "/devices/";
static const char *SERVER_DB_DEVICE_META = "meta";
static const char *SERVER_DB_DEVICE_CONTRACT = "device";

static const char *DEVICE_META_CONTRACT =
"<obj of=\"nextdc:device-meta\">\r\n"
"<str name=\"owner_id\" val=\"%s\"/>\r\n"
"<uri val=\"%s\"/>\r\n"
"</obj>";

static const char *DEVICE_OWNER_ID = "owner_id";

const xmlChar *OBIX_DEVICES = (xmlChar *)"/obix/devices/";

/*
 * Descriptor of a device registered on to the oBIX server, acting
 * as a wrapper or extension of relevant xmlNode in the global DOM
 * tree and providing meta data structure for access control and
 * multi-thread support
 */
typedef struct obix_dev {
	/* The absolute href of the device */
	xmlChar *href;

	/* The unique identifier of the owner */
	char *owner_id;

	/* The absolute pathname of the device's folder on hard-drive */
	char *dir;

	/* The absolute pathname of the device's contract file on hard-drive */
	char *file;

	/* The absolute pathname of the device's meta file on hard-drive */
	char *meta;

	/*
	 * Pointing to the root node of the device contract
	 * in the global DOM tree
	 */
	xmlNode *node;

	/* Pointing to a copy of ref node of the device */
	xmlNode *ref;

	/*
	 * Synchronisation facility to manage the life-cycle of
	 * the device descriptor itself
	 */
	refcnt_t refcnt;

	/*
	 * Synchronisation facility for the accompanied device contract
	 * in multi-thread environment
	 */
	tsync_t sync;

	/*
	 * NOTE: direct children devices may reside on different levels
	 * in the hierarchy of the parent device's subtree. So the Device
	 * subsystem has to organise the relationships among device
	 * descriptors separately from the XML DOM tree
	 */

	/* Pointing to the parent device's descriptor */
	struct obix_dev *parent;

	/* A list of DIRECT children devices' descriptors */
	struct list_head children;

	/* Joining the parent device's children list */
	struct list_head siblings;

	/* Last updated timestamp of the persistent file */
	time_t mtime;
} obix_dev_t;

/*
 * Descriptor for the Device Subsystem on the oBIX server
 */
typedef struct obix_devices {
	/*
	 * The period to update a device's persistent file on
	 * the hard drive
	 */
	int backup_period;

	/*
	 * The hash table of all devices registered, which are
	 * recognisable by their unique hrefs
	 */
	hash_table_t *tab;

	/* The cache used along with the hash table */
	cache_t *cache;

	/* Pointing to the device descriptor of the device root */
	obix_dev_t *device_root;
} obix_devices_t;

static obix_devices_t *_devices;

/*
 * Return 1 if the given href points to the Device root,
 * 0 otherwise
 */
int is_device_root_href(const xmlChar *href)
{
	/*
	 * Must be lenient on the trailing slash, since the parameter
	 * may be generated by dirname() which excludes trailing
	 * slash for every token
	 */
	return is_str_identical(href, obix_roots[OBIX_DEVICE].root, 1);
}

/*
 * Application specific methods to calculate a hash value
 * from the given href. If it starts with the common part of
 * "/obix/deviceRoot/" and longer than it, then skip it over.
 */
static unsigned int device_compute_hash(const xmlChar *href,
										const unsigned int tab_size)
{
	int len = xmlStrlen(href);
	const xmlChar *root = obix_roots[OBIX_DEVICE].root;
	int root_len = obix_roots[OBIX_DEVICE].len;

	if (xmlStrncmp(href, root, root_len) == 0 && len > root_len) {
		href += root_len;
		len -= root_len;
	}

	return hash_bkdr(href, len, tab_size);
}

static int device_compare_str(const xmlChar *href, hash_node_t *node)
{
	obix_dev_t *dev = (obix_dev_t *)(node->item);

	return is_str_identical(href, dev->href, 1);
}

static void device_get(obix_dev_t *dev)
{
	refcnt_get(&dev->refcnt);
}

static void device_put(obix_dev_t *dev)
{
	refcnt_put(&dev->refcnt);
}

static void device_get_wrapper(void *dev)
{
	device_get((obix_dev_t *)dev);
}

static hash_table_ops_t device_hash_ops = {
	.compute = device_compute_hash,
	.compare = device_compare_str,
	.get = device_get_wrapper
};

/* The meta information of a device */
typedef struct meta_info {
	char *owner_id;
	char *href;
} meta_info_t;

/*
 * Read the owner ID and href information of a device from
 * its meta file
 *
 * Return 0 on success, > 0 for error code
 */
static int device_load_meta(const char *path, meta_info_t *info)
{
	struct stat statbuf;
	xmlDoc *doc;
	xmlNode *root;
	int ret = 0;

	errno = 0;
	if (lstat(path, &statbuf) < 0) {
		return (errno == ENOENT) ? 0 : ERR_DISK_IO;
	}

	if (!(doc = xmlReadFile(path, NULL,
							XML_PARSE_OPTIONS_COMMON | XML_PARSE_NODICT)) ||
		!(root = xmlDocGetRootElement(doc)) ||
		!(info->owner_id = xml_get_child_val(root, OBIX_OBJ_STR,
											 DEVICE_OWNER_ID)) ||
		!(info->href = xml_get_child_val(root, OBIX_OBJ_URI, NULL))) {
		log_error("Unable to parse XML document %s", path);
		ret = ERR_NO_MEM;
	}

	if (doc) {
		xmlFreeDoc(doc);
	}

	/* Doesn't have to clean up info since the caller will do it anyway */
	return ret;
}

static int device_load_contract(const char *path, meta_info_t *info);
static int device_load_files(const char *resdir);

/*
 * Load a child device contract from the given folder
 *
 * Return 0 on success, < 0 on error so as to break from
 * the for_each_file_name loop
 */
static int device_load_child(const char *dir, const char *file, void *arg)
{
	struct stat statbuf;
	char *path;
	int ret = 0;

	if (link_pathname(&path, dir, NULL, file, NULL) < 0) {
		log_error("Failed to assemble absolute path name for %s/%s", dir, file);
		return -1;
	}

	/*
	 * Skip over meta or contract files of the parent device,
	 * return 0 so as to move on to the next children device
	 */
	if (lstat(path, &statbuf) < 0 || S_ISDIR(statbuf.st_mode) == 0) {
		free(path);
		return 0;
	}

	if (device_load_files(path) != 0) {
		log_error("Failed to load child device %s", path);
		ret = -1;
	}

	free(path);
	return ret;
}

/*
 * Load all device persistent files from the hard drive
 *
 * Return 0 on success, > 0 for error code
 */
static int device_load_files(const char *resdir)
{
	meta_info_t info = { NULL, NULL };
	char *meta = NULL, *file = NULL;
	int ret = 0;

	/*
	 * Load the meta and contract files in the current directory first,
	 * then move on to its children to ensure the parent device is setup
	 * before any of its children devices.
	 *
	 * It doesn't matter if the meta or contract file is missing, e.g.
	 * in the top directory of the Device Root where the helper function
	 * doesn't need to load anything
	 */
	if (link_pathname(&meta, resdir, NULL, SERVER_DB_DEVICE_META,
					  XML_FILENAME_SUFFIX) < 0 ||
		link_pathname(&file, resdir, NULL, SERVER_DB_DEVICE_CONTRACT,
					  XML_FILENAME_SUFFIX) < 0) {
		log_error("Failed to assemble pathname for persistent files under %s",
				  resdir);
		ret = ERR_NO_MEM;
		goto failed;
	}

	if ((ret = device_load_meta(meta, &info)) != 0) {
		log_error("Failed to load device meta at %s", meta);
		goto failed;
	}

	if ((ret = device_load_contract(file, &info)) != 0) {
		log_error("Failed to load device contract at %s", file);
		goto failed;
	}

	if (for_each_file_name(resdir, NULL, NULL,
						   device_load_child, NULL) < 0) {
		ret = ERR_DISK_IO;
	}

	/* Fall through */

failed:
	if (info.owner_id) {
		free(info.owner_id);
	}

	if (info.href) {
		free(info.href);
	}

	if (meta) {
		free(meta);
	}

	if (file) {
		free(file);
	}

	return ret;
}

/*
 * Remove the given device's persistent files on the hard drive
 */
static void __device_remove_files(obix_dev_t *dev)
{
	if (dev->meta) {
		unlink(dev->meta);
	}

	if (dev->file) {
		unlink(dev->file);
	}

	if (dev->dir) {
		rmdir(dev->dir);
	}
}

/*
 * Create persistent device files on the hard drive for the given device
 *
 * Return 0 on success, > 0 for error code
 */
static int __device_create_files(obix_dev_t *dev)
{
	int fd, ret = ERR_DISK_IO, errno_saved = 0;

	errno = 0;
	if (mkdir(dev->dir, OBIX_DIR_PERM) < 0) {
		log_error("Failed to mkdir %s because of %s", dev->dir,
				  strerror(errno));
		errno_saved = errno;
		goto failed;
	}

	errno = 0;
	if ((fd = creat(dev->file, OBIX_FILE_PERM)) < 0) {
		log_error("Failed to creat %s because of %s", dev->file,
				  strerror(errno));
		errno_saved = errno;
		goto file_failed;
	}
	close(fd);

	errno = 0;
	if ((fd = creat(dev->meta, OBIX_FILE_PERM)) < 0) {
		log_error("Failed to creat %s because of %s", dev->meta,
				  strerror(errno));
		errno_saved = errno;
		goto meta_failed;
	}
	close(fd);

	return 0;

meta_failed:
	unlink(dev->file);

file_failed:
	rmdir(dev->dir);

failed:
	if (errno_saved == EEXIST) {
		log_error("Device persistent files exist but corrupted, "
				  "manually fixup required");
	}

	if (errno_saved == EDQUOT || errno_saved == ENOMEM ||
		errno_saved == ENOSPC) {
		ret = ERR_NO_MEM;
	}

	return ret;
}

static int __device_write_meta(obix_dev_t *dev)
{
	char *buf;
	int len, ret = 0;

	len = strlen(DEVICE_META_CONTRACT) + strlen(dev->owner_id) +
		  xmlStrlen(dev->href) - 4;
	if (!(buf = (char *)malloc(len + 1))) {
		log_error("Failed to allocate buf to assemble meta file for device %s",
				  dev->href);
		return ERR_NO_MEM;
	}
	len = sprintf(buf, DEVICE_META_CONTRACT, dev->owner_id, dev->href);

	if (xml_write_file(dev->meta, OPEN_FLAG_SYNC, buf, len) < 0) {
		log_error("Failed to write meta file at %s", dev->meta);
		ret = ERR_DISK_IO;
	}

	free(buf);
	return ret;
}

static time_t __device_get_file_ts(obix_dev_t *dev)
{
	struct stat statbuf;

	return (lstat(dev->file, &statbuf) == 0) ? statbuf.st_mtime : 0;
}

/*
 * Copy the subtree of a device, EXCLUDING any of its
 * children devices
 */
static xmlNode *__device_copy_no_child(obix_dev_t *parent, const xmlNode *src)
{
	xmlNode *copy_src, *copy_node, *node;

	if (!(copy_src = xmlCopyNode((xmlNode *)src, 2))) {
		return NULL;
	}

	for (node = src->children; node; node = node->next) {
		if ((obix_dev_t *)node->_private != parent ||
			!(copy_node = __device_copy_no_child(parent, node))) {
			continue;
		}

		if (!xmlAddChild(copy_src, copy_node)) {
			xmlFreeNode(copy_node);
			xmlFreeNode(copy_src);
			return NULL;
		}
	}

	return copy_src;
}

/*
 * Dump the content of a device into a buffer, EXCLUDING any of
 * its children devices
 *
 * NOTE: this is NOT a recursive function, since any child device
 * contracts should not be saved into parent's persistent file
 */
static char *__device_dump_device(obix_dev_t *dev)
{
	xmlNode *copy;
	char *buf = NULL;

	/* No children devices */
	if (list_empty(&dev->children) == 1) {
		return xml_dump_node(dev->node);
	}

	/*
	 * Otherwise excluding all its children devices
	 * by making another copy of it
	 */
	if ((copy = __device_copy_no_child(dev, dev->node)) != NULL) {
		buf = xml_dump_node(copy);
		xmlFreeNode(copy);
	}

	return buf;
}

/*
 * Backup the device contract onto its persistent file on the
 * hard-drive and update its last modification timestamp
 *
 * Return 0 on success, > 0 for error code
 */
static int __device_write_file(obix_dev_t *dev, time_t now)
{
	char *buf;
	int ret = 0;

	if (!(buf = __device_dump_device(dev))) {
		log_error("Failed to dump content from device of %s", dev->href);
		return ERR_NO_MEM;
	}

	if (xml_write_file(dev->file, OPEN_FLAG_ASYNC, buf, strlen(buf)) < 0) {
		log_error("Failed to write device file at %s", dev->file);
		ret = ERR_DISK_IO;
	}

	/*
	 * Doesn't matter if now == 0 when the persistent file is initially
	 * created and it will get updated by the first write into the device
	 */
	dev->mtime = now;

	free(buf);
	return ret;
}

/*
 * Get the host device descriptor for the given href
 *
 * Search the hash table on a cache miss. If found, also have
 * the cache udpated
 *
 * NOTE: The reference count of the device descriptor is increased
 * before returned so as to synchronise with deletion threads
 */
static obix_dev_t *device_search(const xmlChar *href)
{
	obix_dev_t *dev = NULL;

	if (is_given_type(href, OBIX_DEVICE) == 0) {
		return NULL;
	}

	if (is_device_root_href(href) == 1) {
		dev = _devices->device_root;
		/*
		 * Need to manually increase the reference count for
		 * the device root since it is not organised in hash table
		 */
		device_get(dev);
		return dev;
	}

	if (!(dev = (obix_dev_t *)cache_search(_devices->cache, href,
										   device_get_wrapper))) {
		if ((dev = (obix_dev_t *)hash_search(_devices->tab, href)) != NULL) {
			cache_update(_devices->cache, dev->href, dev);
		}
	}

	return dev;
}

/*
 * Search for the closest or direct parent device that hosts
 * the given href
 *
 * NOTE: the device may not necessarily actually host a node
 * corresponding to the given href
 */
static obix_dev_t *device_search_parent(const xmlChar *href)
{
	obix_dev_t *dev = NULL;
	xmlChar *parent = NULL;

	if (is_given_type(href, OBIX_DEVICE) == 0 || is_device_root_href(href) == 1) {
		return NULL;
	}

	if (!(parent = xmlStrdup(href)) ||
		!(parent = (xmlChar *)dirname((char *)parent))) {
		return NULL;
	}

	while (!(dev = device_search(parent))) {
		if (!(parent = (xmlChar *)dirname((char *)parent))) {
			/* Won't have to nullify dev since it is assured to be NULL */
			break;
		}
	}

	if (parent) {
		xmlFree(parent);
	}

	return dev;
}

/*
 * Save the current snapshot of the device contract that host the given
 * href onto the hard drive
 *
 * For sake of performance and efficiency, it's not desirable and not
 * necessary at all to save every single change of the device into its
 * persistent file on the hard drive, especially when it's being updated
 * very frequently. Instead, backup should be done when the entire
 * device contract may have been properly updated by client via one
 * batch object
 *
 * Return 0 on success, > 0 for error code
 */
int device_backup_uri(const xmlChar *href)
{
	obix_dev_t *dev;
	time_t now;
	int ret = ERR_INVALID_STATE;

	if (!(dev = device_search_parent(href))) {
		return ERR_DEVICE_NO_SUCH_URI;
	}

	if (tsync_writer_entry(&dev->sync) == 0) {
		if ((now = time(NULL)) >= dev->mtime + _devices->backup_period) {
			ret = __device_write_file(dev, now);
		} else {
			ret = 0;
		}

		tsync_writer_exit(&dev->sync);
	}

	device_put(dev);
	return ret;
}

/*
 * De-associate the given device descriptor from its social network
 */
static void __device_unlink(obix_dev_t *dev)
{
	hash_del(_devices->tab, dev->href);
	cache_invalidate(_devices->cache, dev->href);

	list_del(&dev->siblings);
	dev->parent = NULL;
}

/*
 * Entirely wipe out any data structure related with the given device
 * except its descriptor
 *
 * NOTE: caller must have entered the "write region" of the parent device
 */
static void __device_purge(obix_dev_t *dev, int sign_off)
{
	/* Delete its XML node from the global DOM tree */
	xmldb_delete_node(dev->node, 0);

	/*
	 * Remove its persistent files and folder on the hard-drive when
	 * the device is signed off. However, they are perserved during
	 * normal server shutdown
	 */
	if (sign_off == 1) {
		__device_remove_files(dev);
	}

	/* De-associate from its parent device's network */
	__device_unlink(dev);
}

/*
 * Delete the specified device descriptor
 *
 * NOTE: Callers must take care of following operations before
 * deleting a device descriptor:
 *	1. unlink and delete relevant node from the global DOM tree;
 *	2. de-associate with parent device descriptor;
 *	3. remove from Devices hash table and cache.
 * They are supposed to be completed within the "write region"
 * of its parent device
 */
static void device_dispose(obix_dev_t *dev)
{
	refcnt_sync(&dev->refcnt);

	if (list_empty(&dev->children) == 0) {
		log_warning("Device of %s still have descendant descriptors, "
					"memory leaks on them ensue!", dev->href);
	}

	if (dev->href) {
		free(dev->href);
	}

	if (dev->owner_id) {
		free(dev->owner_id);
	}

	if (dev->dir) {
		free(dev->dir);
	}

	if (dev->file) {
		free(dev->file);
	}

	if (dev->meta) {
		free(dev->meta);
	}

	if (dev->ref) {
		xmlFreeNode(dev->ref);
	}

	refcnt_cleanup(&dev->refcnt);
	tsync_cleanup(&dev->sync);

	free(dev);
}

/*
 * Allocate and initialise a brand-new device descriptor for the node
 * that is going to be added into the global DOM tree
 */
static obix_dev_t *device_init(xmlNode *node, const xmlChar *href,
							   const char *dir, const char *requester_id)
{
	obix_dev_t *dev;

	if (!(dev = (obix_dev_t *)malloc(sizeof(obix_dev_t)))) {
		log_error("Failed to allocate a device descriptor");
		return NULL;
	}
	memset(dev, 0, sizeof(obix_dev_t));

	INIT_LIST_HEAD(&dev->children);
	INIT_LIST_HEAD(&dev->siblings);

	refcnt_init(&dev->refcnt);
	tsync_init(&dev->sync);

	if (!(dev->href = xmlStrdup(href)) ||			/* could be static */
		!(dev->dir = strdup(dir)) ||
		!(dev->owner_id = strdup(requester_id)) ||
		!(dev->ref = xml_create_ref_node(node, href))) {
		log_error("No memory to setup the device descriptor of %s", href);
		goto failed;
	}

	/* No meta and device persistent files for the Device Root */
	if (is_device_root_href(href) == 0) {
		if (link_pathname(&dev->meta, dir, NULL, SERVER_DB_DEVICE_META,
						  XML_FILENAME_SUFFIX) < 0 ||
			link_pathname(&dev->file, dir, NULL, SERVER_DB_DEVICE_CONTRACT,
						  XML_FILENAME_SUFFIX) < 0) {
			log_error("No memory to setup the device descriptor of %s", href);
			goto failed;
		}
	}

	/*
	 * Setup the dual mappings from device node and its descriptor
	 *
	 * NOTE: every single node in the device subtree should have their
	 * _private pointer initialised, sometimes other types of nodes than
	 * elements may be accessed
	 */
	dev->node = node;
	xml_setup_private(node, (void *)dev);

	return dev;

failed:
	device_dispose(dev);
	return NULL;
}

/*
 * Search for a subnode with the given href in the specified
 * device contract
 *
 * NOTE: Callers must have entered either "read region" or
 * "write region" of the device
 */
static xmlNode *__device_get_node_core(obix_dev_t *dev, const xmlChar *href)
{
	xmlNode *node;

	if (is_str_identical(dev->href, href, 1) == 1) {
		node = dev->node;
	} else {
		node = xmldb_get_node_core(dev->node, href + xmlStrlen(dev->href));
	}

	/*
	 * Cache up subnodes' mapping to parent device's descriptor would be
	 * useful only when the server is not busy and the client is using
	 * simple device contract (such as the example_adaptor). However, this
	 * normally won't be the case since oBIX clients can fastly update
	 * their device contracts, as a result, the cache is flushed quickly
	 */
	return node;
}

/*
 * Copy the node from the given device. Basically it's similar to
 * xml_copy_r() but takes extra care of coming across "read region"
 * of the parent and child devices
 */
static xmlNode *__device_copy_node(obix_dev_t *parent, const xmlNode *src,
								   xml_copy_flags_t flags, int depth)
{
	obix_dev_t *child;
	xmlNode *node, *copy_src = NULL, *copy_node = NULL;
	int ret = ERR_NO_MEM;

	/*
	 * If moving out of the parent device's bourndary and into that of
	 * the child device, come across different "read regions" accordingly
	 *
	 * Always increase the reference count of a particular child device
	 * when it is accessed, even though the "read region" of the parent
	 * device has been entered which can already effectively prevent it
	 * from being deleted
	 */
	if ((child = (obix_dev_t *)src->_private) != parent) {
		tsync_reader_exit(&parent->sync);
		device_get(child);
		if (tsync_reader_entry(&child->sync) < 0) {
			device_put(child);
			tsync_reader_entry(&parent->sync);
			return NULL;
		}
	}

	/*
	 * If hidden, meta or comment nodes are not explicitly required,
	 * they may be skipped over according to the flag
	 */
	if (depth > 0) {
		if (((flags & EXCLUDE_HIDDEN) > 0 && xml_is_hidden(src) == 1) ||
			((flags & EXCLUDE_META) > 0 &&
			 xmlStrcmp(src->name, BAD_CAST OBIX_OBJ_META) == 0) ||
			((flags & EXCLUDE_COMMENTS) > 0 && src->type == XML_COMMENT_NODE)) {
			ret = 0;
			goto out;
		}
	}

	if (!(copy_src = xmlCopyNode((xmlNode *)src, 2))) {
		log_error("Failed to copy a node");
		goto out;
	}

	for (node = src->children; node; node = node->next) {
		if (!(copy_node = __device_copy_node(child, node, flags, ++depth))) {
			/*
			 * The current child may have been deliberatly excluded,
			 * move on to the next one
			 */
			continue;
		}

		if (!xmlAddChild(copy_src, copy_node)) {
			log_error("Failed to organise a node's copy from device %s",
					  parent->href);
			xmlFreeNode(copy_node);
			goto out;
		}
	}

	ret = 0;

	/* Fall through */

out:
	if (child != parent) {
		tsync_reader_exit(&child->sync);
		device_put(child);

		/*
		 * There isn't much what we can do if failed to re-enter
		 * the "read region" of the parent device
		 */
		tsync_reader_entry(&parent->sync);
	}

	if (ret > 0 && copy_src) {
		xmlFreeNode(copy_src);
		copy_src = NULL;
	}

	return copy_src;
}

/*
 * Copy a device node
 *
 * NOTE: To avoid race conditions, the "get + copy" operations
 * must be done atomically
 */
xmlNode *device_copy_uri(const xmlChar *href, xml_copy_flags_t flags)
{
	obix_dev_t *dev;
	xmlNode *node, *copy = NULL;

	if (!(dev = device_search(href)) &&
		!(dev = device_search_parent(href))) {
		return NULL;
	}

	if (tsync_reader_entry(&dev->sync) == 0) {
		if ((node = __device_get_node_core(dev, href)) != NULL) {
			copy = __device_copy_node(dev, node, flags, 0);
		}

		tsync_reader_exit(&dev->sync);
	}

	device_put(dev);
	return copy;
}

static void __device_notify_watches(obix_dev_t *previous, xmlNode *node)
{
	obix_dev_t *current;
	xmlNode *n;
	long id;

	if (!(current = (obix_dev_t *)node->_private)) {
		return;		/* reached the parent of "/obix/deviceRoot/" */
	}

	/*
	 * Transition from the "read region" from the children device to
	 * that of the parent if needed
	 */
	if (current != previous) {
		tsync_reader_exit(&previous->sync);
		device_get(current);
		if (tsync_reader_entry(&current->sync) < 0) {
			device_put(current);
			return;
		}
	}

	/*
	 * Notify all watches that may have been monitoring the current node
	 */
	for (n = node->children; n; n = n->next) {
		if (n->type != XML_ELEMENT_NODE ||
			xmlStrcmp(n->name, BAD_CAST OBIX_OBJ_META) != 0 ||
			(id = xml_get_long(n, OBIX_META_ATTR_WATCH_ID)) < 0) {
			continue;
		}

		watch_notify_watches(id, node, WATCH_EVT_NODE_CHANGED);
	}

	__device_notify_watches(current, node->parent);

	if (current != previous) {
		tsync_reader_exit(&current->sync);
		device_put(current);
		tsync_reader_entry(&previous->sync);
	}
}

/*
 * Recursively traverse the entire subtree of the given node,
 * nullify relevant watch items' reference to any subnode
 */
static void __device_nullify_watch_items(xmlNode *node)
{
	xmlNode *n;
	long id;

	if (!node) {
		return;
	}

	for (n = node->children; n; n = n->next) {
		if (n->type != XML_ELEMENT_NODE) {
			continue;
		}

		if (xmlStrcmp(n->name, BAD_CAST OBIX_OBJ_META) == 0) {
			if ((id = xml_get_long(n, OBIX_META_ATTR_WATCH_ID)) >= 0) {
				watch_notify_watches(id, node, WATCH_EVT_NODE_DELETED);
			}

			continue;
		}

		__device_nullify_watch_items(n);
	}
}

/*
 * Notify watches monitoring the given node in a device contract
 * of the changes on the node.
 *
 * Recursively move upward to any ancestors of the given node
 * until the root of Device subsystem and notify any watches on
 * them as well
 */
static void device_notify_watches(obix_dev_t *dev, xmlNode *node)
{
	if (tsync_reader_entry(&dev->sync) < 0) {
		return;
	}

	__device_notify_watches(dev, node);

	tsync_reader_exit(&dev->sync);
}

/*
 * Update the val attribute on the given device node and
 * notify relevant watch objects if the val attribute is
 * first set or changed
 *
 * Return 0 on success, > 0 for error code
 */
int device_update_uri(const xmlChar *href, const xmlChar *new)
{
	obix_dev_t *dev;
	xmlNode *node = NULL;
	xmlChar *old = NULL;
	int changed = 0, ret = ERR_INVALID_STATE;

	if (!(dev = device_search(href)) &&
		!(dev = device_search_parent(href))) {
		return ERR_DEVICE_NO_SUCH_URI;
	}

	if (tsync_writer_entry(&dev->sync) == 0) {
		if ((node = __device_get_node_core(dev, href)) != NULL) {
			ret = 0;
			if (!(old = xmlGetProp(node, BAD_CAST OBIX_ATTR_VAL)) ||
				xmlStrcmp(old, new) != 0) {
				if (!xmlSetProp(node, BAD_CAST OBIX_ATTR_VAL, new)) {
					log_error("Failed to set the val attribute within %s", dev->href);
					ret = ERR_NO_MEM;
				} else {
					changed = 1;
				}
			}
		} else {
			ret = ERR_DEVICE_NO_SUCH_URI;
		}

		tsync_writer_exit(&dev->sync);
	}

	if (changed == 1 && node) {
		device_notify_watches(dev, node);
	}

	device_put(dev);

	if (old) {
		xmlFree(old);
	}

	return ret;
}

/*
 * Setup the required social network for the given device descriptor
 *
 * Return 0 on success, > 0 for error codes
 */
static int __device_link(obix_dev_t *child, obix_dev_t *parent)
{
	if (hash_add(_devices->tab, child->href, child) != 0) {
		return ERR_NO_MEM;
	}

	cache_update(_devices->cache, child->href, child);

	list_add_tail(&child->siblings, &parent->children);
	child->parent = parent;
	return 0;
}

/*
 * Delete the specified device with the given href
 *
 * Return 0 on success, > 0 for error code
 */
int device_del(const xmlChar *href, const char *requester_id, int sign_off)
{
	obix_dev_t *dev, *parent = NULL, *child, *n;
	xmlNode *mount_point;
	int ret = 0;

	if (!(dev = device_search(href))) {
		return ERR_DEVICE_NO_SUCH_URI;
	}

	/*
	 * Check if the current thread has the permission to delete
	 * relevant device
	 */
	if (se_lookup(requester_id, dev->owner_id, OP_DEVICE_DELETE) == 0) {
		log_error("\"%s\" permission denied to delete device of %s "
				  "owned by \"%s\"",
				  requester_id, dev->href, dev->owner_id);
		ret = ERR_PERM_DENIED;
		goto failed;
	}

	/*
	 * Check if the current thread has the permission to remove
	 * the device from its parent
	 *
	 * NOTE: the device root has no parent
	 */
	if (!(parent = dev->parent) && dev != _devices->device_root) {
		ret = ERR_DEVICE_ORPHAN;
		goto failed;
	}

	if (parent) {
		device_get(parent);

		if (se_lookup(requester_id, parent->owner_id, OP_DEVICE_REMOVE) == 0) {
			log_error("\"%s\" permission denied to remove child device of %s "
					  "from parent device owned by \"%s\"",
					  requester_id, dev->href, parent->owner_id);
			ret = ERR_PERM_DENIED;
			goto failed;
		}
	}

	/*
	 * Signal that the device is shutting down to ensure no further
	 * reader nor writer. Upon return any existing readers and writers
	 * are ensured completed and exited and the current thread can
	 * enjoy exclusive access to the device
	 */
	if (tsync_shutdown_entry(&dev->sync) < 0) {
		ret = ERR_DEVICE_NO_SUCH_URI;
		goto failed;
	}

	/*
	 * Checking if any other threads may have added new children under
	 * the to-be-deleted device must be placed after a clearance of
	 * any other writers
	 */
	if (list_empty(&dev->children) == 0) {
		if (sign_off == 1) {
			log_error("Unable to delete Device %s due to existing children",
					  dev->href);
			tsync_shutdown_revoke(&dev->sync);
			ret = ERR_DEVICE_CHILDREN;
			goto failed;
		} else {
			list_for_each_entry_safe(child, n, &dev->children, siblings) {
				if (device_del(child->href, requester_id, 0) != 0) {
					log_error("Failed to delete device of %s", child->href);
					/*
					 * Keep on going because unable to recovery since some children
					 * may have been deleted
					 */
				}
			}
		}
	}

	/*
	 * Notify watches in the to-be-deleted device contract
	 * before it gets removed
	 */
	__device_nullify_watch_items(dev->node);

	if (parent && sign_off == 1) {
		/*
		 * Will fail when the parent device already marked as shut down,
		 * e.g., another thread trying to delete the parent device directly,
		 * although such attempt will get revoked shortly after
		 *
		 * Busy waiting until entering the "write region" of the parent
		 * device successfully
		 *
		 * NOTE: removal of a child devcie must synchronise with other
		 * threads trying to change the same parent device concurrently
		 */
		while (tsync_writer_entry(&parent->sync) < 0) {
			sleep(1);
		}
	}

	mount_point = dev->node->parent;

	__device_purge(dev, 1);

	if (parent && sign_off == 1) {
		tsync_writer_exit(&parent->sync);

		/*
		 * Notify watches in the ancestors of the to-be-deleted
		 * device contract after the removal has been done
		 */
		device_notify_watches(parent, mount_point);
	}

	/* Fall through */

failed:
	if (parent) {
		device_put(parent);
	}

	device_put(dev);

	if (ret == 0) {
		device_dispose(dev);
	}

	return ret;
}

/*
 * Add the given node into the global DOM tree, also setup its device
 * descriptor and the link with that of the parent device
 *
 * Return 0 on success, > 0 for error code
 */
int device_add(xmlNode *input, const xmlChar *href, const char *requester_id,
			   int sign_up)		/* == 0 if loadded from persistent files */
{
	obix_dev_t *parent, *child = NULL, *dev;
	xmlNode *mount_point;
	xmlChar *mount_point_href = NULL, *name = NULL;
	char *dir;
	int ret = 0;

	if (!(parent = device_search_parent(href))) {
		log_error("Failed to find the parent device for %s", href);
		return ERR_DEVICE_NO_SUCH_URI;
	}

	if (!(mount_point_href = xmlStrdup(href)) ||
		!(mount_point_href = (xmlChar *)dirname((char *)mount_point_href))) {
		ret = ERR_NO_MEM;
		goto failed;
	}

	/*
	 * Devices are expected to have unique names in the scope of one oBIX
	 * server so that their persistent files can differ from each other
	 */
	if (!(name = xmlGetProp(input, BAD_CAST OBIX_ATTR_NAME))) {
		log_error("Failed to get the new device's name at %s", href);
		ret = ERR_NO_NAME;
		goto failed;
	}

	if (link_pathname(&dir, parent->dir, NULL, (const char *)name, NULL) < 0 ||
		!(child = device_init(input, href, dir, requester_id))) {
		log_error("Failed to initialise a device descriptor for %s", href);
		ret = ERR_NO_MEM;
		goto failed;
	}

	if (se_lookup(requester_id, parent->owner_id, OP_DEVICE_ADD) == 0) {
		log_error("Permission denied to sign up new device of %s", href);
		ret = ERR_PERM_DENIED;
		goto failed;
	}

	if (tsync_writer_entry(&parent->sync) < 0) {
		ret = ERR_INVALID_STATE;
		goto failed;
	}

	/*
	 * Re-check if the client has registered the same device already
	 * since multiple signUp requests for the same device may be raised
	 * in parallel.
	 *
	 * This will also enable a re-started client signUp gracefully
	 */
	list_for_each_entry(dev, &parent->children, siblings) {
		if (is_str_identical(dev->href, href, 1) == 1) {
			tsync_writer_exit(&parent->sync);
			log_debug("Device of %s already signed up by %s",
					  href, dev->owner_id);
			ret = (strcmp(dev->owner_id, requester_id) == 0) ?
						ERR_DEVICE_EXISTS : ERR_DEVICE_CONFLICT_OWNER;
			goto failed;
		}
	}

	if (!(mount_point = __device_get_node_core(parent, mount_point_href))) {
		tsync_writer_exit(&parent->sync);
		log_error("Failed to get the mount point for new device at %s", href);
		ret = ERR_DEVICE_NO_SUCH_URI;
		goto failed;
	}

	/*
	 * NOTE: hrefs in persistent device files are relative already
	 */
	if ((ret = xmldb_add_child(mount_point, input, 1, sign_up)) != 0) {
		tsync_writer_exit(&parent->sync);
		log_error("Failed to add device of %s into global DOM tree", href);
		goto failed;
	}

	if ((ret = __device_link(child, parent)) != 0) {
		xmlUnlinkNode(input);
		tsync_writer_exit(&parent->sync);
		log_error("Failed to add device of %s into parent network", href);
		goto failed;
	}

	/*
	 * Only create persistent files for newly signed up devices,
	 * on failure they are signed off
	 */
	if (sign_up == 1) {
		if ((ret = __device_create_files(child)) != 0 ||
			(ret = __device_write_meta(child)) != 0 ||
			(ret = __device_write_file(child, 0)) != 0) {
			__device_remove_files(child);
			__device_unlink(child);
			xmlUnlinkNode(input);
			tsync_writer_exit(&parent->sync);
			log_error("Failed to setup device persistent files for %s", href);
			goto failed;
		}
	} else {
		child->mtime = __device_get_file_ts(child);
		ret = 0;
	}

	tsync_writer_exit(&parent->sync);

	/* Notifying ancestors of the newly added device once it has been added */
	if (sign_up == 1 && mount_point) {
		device_notify_watches(parent, mount_point);
	}

	/* Fall through */

failed:
	device_put(parent);

	if (name) {
		xmlFree(name);
	}

	if (mount_point_href) {
		xmlFree(mount_point_href);
	}

	if (dir) {
		free(dir);
	}

	if (ret > 0 && child) {
		device_dispose(child);
	}

	/*
	 * If the device has been registered by the same client before, regard
	 * the current attempt as success. However, the extra copy of the input
	 * device contract must be explicitly released since the caller will
	 * consider it added to the global DOM tree on success
	 */
	if (ret == ERR_DEVICE_EXISTS) {
		xmlFreeNode(input);
		ret = 0;
	}

	return ret;
}

/*
 * Load the device persistent file into the oBIX server, in particular,
 * add the device contract into the global DOM tree and have its descriptor
 * created and registered
 *
 * Return 0 on success, > 0 for error code
 */
static int device_load_contract(const char *path, meta_info_t *info)
{
	struct stat statbuf;
	xmlDoc *doc;
	xmlNode *root;
	int ret = 0;

	errno = 0;
	if (lstat(path, &statbuf) < 0) {
		return (errno == ENOENT) ? 0 : ERR_DISK_IO;
	}

	if (!(doc = xmlReadFile(path, NULL,
							XML_PARSE_OPTIONS_COMMON | XML_PARSE_NODICT)) ||
		!(root = xmlDocGetRootElement(doc))) {
		log_error("Unable to parse XML document %s", path);
		ret = ERR_NO_MEM;
	} else {
		ret = device_add(root, BAD_CAST info->href, info->owner_id, 0);
	}

	if (doc) {
		xmlFreeDoc(doc);
	}

	return ret;
}

/*
 * Link a new child node under the parent node with the given href
 * and backup its device contract onto the hard drive if needed
 *
 * Return 0 on success, > 0 for error code. If success, the updated
 * parameter will point to the parent node in the device contract
 * that just has a new child added
 *
 * NOTE: use with care, since the pointer to the parent node is
 * returned and it must be nullified when relevant device contract
 * is removed
 */
int device_link_single_node(const xmlChar *href, xmlNode *node,
							xmlNode **updated, int backup)
{
	obix_dev_t *dev;
	xmlNode *parent;
	int ret = 0;

	*updated = NULL;

	if (!(dev = device_search(href)) &&
		!(dev = device_search_parent(href))) {
		return ERR_DEVICE_NO_SUCH_URI;
	}

	if (tsync_writer_entry(&dev->sync) < 0) {
		ret = ERR_INVALID_STATE;
		goto failed;
	}

	if (!(parent = __device_get_node_core(dev, href))) {
		tsync_writer_exit(&dev->sync);
		ret = ERR_DEVICE_NO_SUCH_URI;
		goto failed;
	}

	if (!xmlAddChild(parent, node)) {
		tsync_writer_exit(&dev->sync);
		ret = ERR_NO_MEM;
		goto failed;
	}

	*updated = parent;
	node->_private = dev;

	if (backup == 1) {
		__device_write_file(dev, 0);
	}

	tsync_writer_exit(&dev->sync);

	/* Fall through */

failed:
	device_put(dev);
	return ret;
}

/*
 * Remove the given node from the parent node with the given href
 * and backup its device contract onto the hard drive if needed
 *
 * Return 0 on success, > 0 for error code
 *
 * NOTE: It's the caller's responsibility to further release the
 * given node once it is de-associated with its parent
 */
int device_unlink_single_node(const xmlChar *href, xmlNode *node, int backup)
{
	obix_dev_t *dev;
	int ret = 0;

	if (!(dev = device_search(href)) &&
		!(dev = device_search_parent(href))) {
		return ERR_DEVICE_NO_SUCH_URI;
	}

	if (tsync_writer_entry(&dev->sync) < 0) {
		ret = ERR_INVALID_STATE;
		goto failed;
	}

	xmlUnlinkNode(node);

	if (backup == 1) {
		__device_write_file(dev, 0);
	}

	tsync_writer_exit(&dev->sync);

	/* Fall through */

failed:
	device_put(dev);
	return ret;
}

/*
 * Read value of the "op" attribute in the meta node
 * in a device contract
 *
 * Return 0 on success, > 0 for error code
 */
int device_get_op_id(const xmlChar *href, long *id)
{
	obix_dev_t *dev;
	xmlNode *node;
	int ret = ERR_INVALID_STATE;

	if (!(dev = device_search(href)) &&
		!(dev = device_search_parent(href))) {
		return ERR_DEVICE_NO_SUCH_URI;
	}

	if (tsync_reader_entry(&dev->sync) == 0) {
		if ((node = __device_get_node_core(dev, href)) != NULL) {
			ret = xmldb_get_op_id_core(node, id);
		} else {
			ret = 0;
		}

		tsync_reader_exit(&dev->sync);
	}

	device_put(dev);
	return ret;
}

xmlNode *device_dump_ref(void)
{
	xmlNode *copy, *ref, *ref_copy;
	hash_head_t *head;
	hash_node_t *hn;
	int i;

	if (!(copy = xmldb_copy_uri(OBIX_DEVICES, 0))) {
		log_error("Failed to copy from %s", OBIX_DEVICES);
		return NULL;
	}

	xmlUnsetProp(copy, BAD_CAST OBIX_ATTR_HIDDEN);
	xmlSetProp(copy, BAD_CAST OBIX_ATTR_HREF, OBIX_DEVICES);

	for (i = 0; i < _devices->tab->size; i++) {
		head = &_devices->tab->table[i];

		tsync_reader_entry(&head->sync);	/* Won't fail */

		list_for_each_entry(hn, &head->head, list) {
			ref = ((obix_dev_t *)(hn->item))->ref;
			if (!(ref_copy = xmlCopyNode(ref, 1)) ||
				!xmlAddChild(copy, ref_copy)) {
				tsync_reader_exit(&head->sync);
				goto failed;
			}
		}

		tsync_reader_exit(&head->sync);
	}

	return copy;

failed:
	if (ref_copy) {
		xmlFreeNode(ref_copy);
	}

	xmlFreeNode(copy);
	return NULL;
}

void obix_devices_dispose(void)
{
	if (!_devices) {
		return;
	}

	if (_devices->device_root) {
		/*
		 * Recursively deleting all remaining registered devices
		 * when the server is shutting down to prevent memory leaks.
		 * The persistent device facilities on hard drive will help
		 * server recover at next start-up
		 */
		device_del(obix_roots[OBIX_DEVICE].root, OBIX_ID_DEVICE, 0);
	}

	if (_devices->cache) {
		cache_dispose(_devices->cache);
	}

	if (_devices->tab) {
		hash_destroy_table(_devices->tab);
	}

	free(_devices);
	_devices = NULL;

	log_debug("The Device subsystem disposed");
}

int obix_devices_init(const char *resdir, const int table_size,
					  const int cache_size, const int backup_period)
{
	xmlNode *root;
	char *dir;

	if (link_pathname(&dir, resdir, NULL, SERVER_DB_DEVICES, NULL) < 0) {
		log_error("Failed to assemble pathname for persistent device database");
		return ERR_NO_MEM;
	}

	if (!(_devices = (obix_devices_t *)malloc(sizeof(obix_devices_t)))) {
		log_error("Failed to allocate descriptor for the Device subsystem");
		goto failed;
	}
	memset(_devices, 0, sizeof(obix_devices_t));

	_devices->backup_period = backup_period;

	if (!(_devices->tab = hash_init_table(table_size, &device_hash_ops))) {
		log_error("Failed to allocate hash table for the Device subsystem");
		goto failed;
	}

	if (!(_devices->cache = cache_init(cache_size))) {
		log_error("Failed to allocate cache for the Device subsystem");
		goto failed;
	}

	if (!(root = xmldb_get_node(obix_roots[OBIX_DEVICE].root)) ||
		!(_devices->device_root = device_init(root, obix_roots[OBIX_DEVICE].root,
											  dir, OBIX_ID_DEVICE))) {
		log_error("Failed to setup a device descriptor for the Device Root");
		goto failed;
	}

	if (device_load_files(dir) != 0) {
		log_error("Failed to load device persistent files from %s", dir);
		goto failed;
	}

	free(dir);

	log_debug("The Device subsystem initialised");
	return 0;

failed:
	free(dir);
	obix_devices_dispose();

	return ERR_NO_MEM;
}

#ifdef DEBUG
xmlNode *device_dump(void)
{
	hash_table_t *tab = _devices->tab;
	hash_head_t *head;
	hash_node_t *node;
	xmlNode *dump = NULL, *list = NULL, *item = NULL;
	int i, ret = 0;
	char buf[32];

	if (!(dump = xmlNewNode(NULL, BAD_CAST OBIX_OBJ_LIST))) {
		ret = ERR_NO_MEM;
		goto failed;
	}

	/* Being lazy on checking return value for debug functions */
	sprintf(buf, "%d", tab->size);
	xmlSetProp(dump, BAD_CAST OBIX_ATTR_NAME, BAD_CAST "Device Hash Table");
	xmlSetProp(dump, BAD_CAST "size", BAD_CAST buf);
	xmlSetProp(dump, BAD_CAST OBIX_ATTR_OF, BAD_CAST "obix:list");

	for (i = 0; i < tab->size; i++) {
		head = &tab->table[i];

		if (!(list = xmlNewNode(NULL, BAD_CAST OBIX_OBJ_LIST))) {
			ret = ERR_NO_MEM;
			break;
		}

		sprintf(buf, "Queue %d", i);
		xmlSetProp(list, BAD_CAST OBIX_ATTR_NAME, BAD_CAST buf);
		xmlSetProp(list, BAD_CAST OBIX_ATTR_OF, BAD_CAST "obix:uri");

		tsync_reader_entry(&head->sync);

		sprintf(buf, "%d", head->count);
		xmlSetProp(list, BAD_CAST "len", BAD_CAST buf);

		list_for_each_entry(node, &head->head, list) {
			if (!(item = xmlNewNode(NULL, BAD_CAST OBIX_OBJ_URI)) ||
				!xmlSetProp(item, BAD_CAST OBIX_ATTR_VAL,
							((obix_dev_t *)node->item)->href) ||
				!xmlAddChild(list, item)) {
				ret = ERR_NO_MEM;
				break;
			}
		}

		tsync_reader_exit(&head->sync);

		if (ret > 0 || !xmlAddChild(dump, list)) {
			ret = ERR_NO_MEM;
			break;
		}
	}

	/* Fall through */

failed:
	if (ret > 0) {
		if (item) {
			xmlFreeNode(item);
		}

		if (list) {
			xmlFreeNode(list);
		}

		if (dump) {
			xmlFreeNode(dump);
		}

		dump = xmldb_fatal_error();
	}

	return dump;
}

xmlNode *device_cache_dump(void)
{
	cache_t *cache = _devices->cache;
	xmlNode *dump = NULL, *list = NULL, *item = NULL;
	const xmlChar *href;
	char buf[32];
	int ret = 0, i;

	if (!(dump = xmlNewNode(NULL, BAD_CAST OBIX_OBJ)) ||
		!(list = xmlNewNode(NULL, BAD_CAST OBIX_OBJ_LIST)) ||
		!xmlAddChild(dump, list)) {
		ret = ERR_NO_MEM;
		goto failed;
	}

	xmlSetProp(dump, BAD_CAST OBIX_ATTR_NAME, BAD_CAST "Device Cache");
	xmlSetProp(list, BAD_CAST OBIX_ATTR_NAME, BAD_CAST "Cache slots");
	xmlSetProp(list, BAD_CAST OBIX_ATTR_OF, BAD_CAST "obix:uri");

	pthread_mutex_lock(&cache->mutex);

	sprintf(buf, "%ld", cache->hit);
	xmlSetProp(dump, BAD_CAST "hit", BAD_CAST buf);

	sprintf(buf, "%ld", cache->miss);
	xmlSetProp(dump, BAD_CAST "miss", BAD_CAST buf);

	for (i = 0; i < cache->len; i++) {
		href = (cache->items[i].href) ? cache->items[i].href : BAD_CAST "NULL";
		if (!(item = xmlNewNode(NULL, BAD_CAST OBIX_OBJ_URI)) ||
			!xmlSetProp(item, BAD_CAST OBIX_ATTR_VAL, href) ||
			!xmlAddChild(list, item)) {
			ret = ERR_NO_MEM;
			break;
		}
	}

	pthread_mutex_unlock(&cache->mutex);

failed:
	if (ret > 0) {
		if (list) {
			xmlFreeNode(list);
		}

		if (dump) {
			xmlFreeNode(dump);
		}

		dump = xmldb_fatal_error();

	}

	return dump;
}
#endif
