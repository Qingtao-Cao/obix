/* *****************************************************************************
 * Copyright (c) 2013-2015 Qingtao Cao
 * Copyright (c) 2009 Andrey Litvinov
 *
 * This file is part of oBIX
 *
 * oBIX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * oBIX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with oBIX. If not, see <http://www.gnu.org/licenses/>.
 *
 * *****************************************************************************/

#include <stdlib.h>
#include <string.h>			/* memset */
#include <errno.h>
#include "log_utils.h"
#include "ptask.h"

/*
 * Converts milliseconds into timespec structure
 */
static void timespec_fromMillis(struct timespec *time, long millis)
{
	time->tv_sec = millis / 1000;
	time->tv_nsec = (millis % 1000) * 1000000;
}

/*
 * Adds time from the second argument to the first one
 */
static int timespec_add(struct timespec *time1, const struct timespec *time2)
{
	long newNano = time1->tv_nsec + time2->tv_nsec;

	time1->tv_sec += time2->tv_sec + (newNano / 1000000000);
	time1->tv_nsec = newNano % 1000000000;

	/* Adjust in case of negative value */
	if ((time1->tv_nsec < 0) && (time1->tv_sec > 0)) {
		time1->tv_sec--;
		time1->tv_nsec = 1000000000 + time1->tv_nsec;
	} else if ((time1->tv_sec < 0) && (time1->tv_nsec > 0)) {
        time1->tv_sec++;
        time1->tv_nsec = time1->tv_nsec - 1000000000;
	}

	/* Return 1 if the result is valid, -1 otherwise */
	return ((time1->tv_sec >= 0) && (time1->tv_nsec >= 0)) ? 1 : -1;
}

static void timespec_copy(struct timespec *dest, const struct timespec *source)
{
	dest->tv_sec = source->tv_sec;
	dest->tv_nsec = source->tv_nsec;
}

/**
 * Compares value of two time structures.
 *
 * Return 1 if time1 > time2, 0 if they are equal, or
 * -1 if time1 < time2
 */
static int timespec_cmp(struct timespec *time1, struct timespec *time2)
{
	if (time1->tv_sec > time2->tv_sec) {
		return 1;
	} else if (time1->tv_sec < time2->tv_sec) {
		return -1;
	} else {
		if (time1->tv_nsec > time2->tv_nsec) {
			return 1;
		} else if (time1->tv_nsec < time2->tv_nsec) {
			return -1;
		} else {
			return 0;
		}
	}
}

/*
 * Remove the given periodic task from the worker thread's queue
 */
static void __periodicTask_removeFromList(Task_Thread *thread,
										  Periodic_Task *ptask)
{
	if (ptask->prev) {
		ptask->prev->next = ptask->next;
	} else {
		/* removed task from the top of the list */
		thread->taskList = ptask->next;
	}

	if (ptask->next) {
		ptask->next->prev = ptask->prev;
	}

	ptask->prev = LIST_POISON1;
	ptask->next = LIST_POISON2;
}

/**
 * Sets next execution time for the task, which will be used to
 * decide its position in the tasklist.
 * Insert new tasks into tasklist, or re-sort tasklist once
 * existing tasks got updated.
 *
 * @note This should be called while taskListMutex is held.
 */
static void __periodicTask_generateNextExecTime(Task_Thread *thread,
												Periodic_Task *ptask,
												int newly_created)
{
	Periodic_Task *prev = NULL, *next = NULL;

	/*
	 * Next execution time is generated by adding period to last time
	 * when the task is supposed to be executed.
	 */
	timespec_add(&(ptask->nextScheduledTime), &(ptask->period));

	/*
	 * Arrange the tasklist so that tasks are strictly sorted in
	 * ascending order of the next execution time
	 *
	 * For the newly added task, the start of tasklist is searched from
	 *
	 * For executed or reset task, however, since its next execution time
	 * is bumped later, it will always be moved back along the tasklist
	 */
	if (newly_created == 1) {
		prev = NULL;
		next = thread->taskList;
	} else {
		prev = ptask->prev;
		next = ptask->next;

		/* Optimization of the case when there is only one item in queue */
		if (!prev && !next) {
			return;
		}

		__periodicTask_removeFromList(thread, ptask);
	}

	/* Find a suitable position for the new task */
	while (next && (timespec_cmp(&ptask->nextScheduledTime,
								 &next->nextScheduledTime) == 1)) {
		prev = next;
		next = next->next;
	}

	/* Now insert new task between [prev, next] */
	if (prev) {
		prev->next = ptask;
	} else {
		thread->taskList = ptask;
	}
	ptask->prev = prev;

	if (next) {
		next->prev = ptask;
	}
    ptask->next = next;
}

/** Updates task execution period. */
static void __periodicTask_setPeriod(Periodic_Task *ptask,
									 long period,
									 int executeTimes)
{
	timespec_fromMillis(&ptask->period, period);

	ptask->executeTimes = executeTimes;
}

/**
 * Sets next execution time for the task as (current time + execution period).
 *
 * Current thread's tasklist will be re-sorted.
 */
static void __periodicTask_resetExecTime(Task_Thread *thread,
										 Periodic_Task *ptask,
										 int newly_created)
{
	clock_gettime(CLOCK_REALTIME, &ptask->nextScheduledTime);

	__periodicTask_generateNextExecTime(thread, ptask, newly_created);
}

/**
 * Creates new instance of periodic task based on provided parameters.
 * Inserts it into current thread's tasklist based on when its next
 * execution time is going to be triggered.
 */
static Periodic_Task *__periodicTask_create(Task_Thread *thread,
											periodic_task task, /* workload */
											void *arg,
											long period,
											int executeTimes)
{
	Periodic_Task *ptask;

	if (!(ptask = (Periodic_Task *)malloc(sizeof(Periodic_Task)))) {
		log_error("Failed to allocate new periodic task");
		return NULL;
	}
	memset(ptask, 0, sizeof(Periodic_Task));

	ptask->task = task;
	ptask->arg = arg;
	ptask->id = thread->id_gen++;
	ptask->prev = LIST_POISON1;
	ptask->next = LIST_POISON2;

	__periodicTask_setPeriod(ptask, period, executeTimes);
	__periodicTask_resetExecTime(thread, ptask, 1);

	return ptask;
}

/**
 * Executes scheduled task and schedules it for next execution if needed.
 *
 * NOTE: callers expect the mutex still be held upon return
 */
static void __periodicTask_execute(Task_Thread* thread, Periodic_Task* ptask)
{
    ptask->isExecuting = 1;

	/*
	 * Release mutex for two reasons:
	 * 1. execution of a user-defined task may take considerable time
	 * 2. the stopTask requires to grab the mutex again in order to delete
	 *	  the whole task queue
	 */
	pthread_mutex_unlock(&(thread->taskListMutex));
	(ptask->task)(ptask->arg);	/* stopTask never returns */
	pthread_mutex_lock(&(thread->taskListMutex));

    /*
     * Check whether this task is about to be cancelled. If yes,
     * notify the deletion thread to move on to remove it
     */
	if (ptask->isCancelled == 1) {
		pthread_cond_signal(&thread->taskExecuted);
		return;
	}

    ptask->isExecuting = 0;

    /* Check whether we need to schedule next execution time */
    if (ptask->executeTimes != EXECUTE_INDEFINITE) {
		if (--ptask->executeTimes == 0) {
            __periodicTask_removeFromList(thread, ptask);
            free(ptask);
            return;
        }
    }

    /* Caculate the next execution time, re-arrange the tasklist if needed */
    __periodicTask_generateNextExecTime(thread, ptask, 0);
}

static Periodic_Task *__periodicTask_get(Task_Thread *thread, int id)
{
	Periodic_Task *ptask = thread->taskList;

	while(ptask && (ptask->id != id)) {
		ptask = ptask->next;
	}

	return ptask;
}

/** Releases memory allocated by whole tasks in the task list. */
static void __periodicTask_deleteRecursive(Periodic_Task *ptask)
{
	if (!ptask) {
		return;
	}

	__periodicTask_deleteRecursive(ptask->next);

	free(ptask);
}

/** Main working cycle which executed tasks. */
static void *threadCycle(void *arg)
{
	Task_Thread *thread = (Task_Thread *)arg;
	Periodic_Task *ptask = NULL;
	struct timespec next;
	int waitState;

	pthread_mutex_lock(&thread->taskListMutex);

	/*
	 * Endless cycle to wait and process the periodic tasks in the queue.
	 * The thread is stopped by a special task of stopTask.
	 */
	while (1) {
		/*
		 * Wait for any task added to the queue, and return the closest one
		 *
		 * Thanks to the fact that tasklist is strictly sorted based on the
		 * ascending order to tasks' next execution time, the very first item
		 * should always be returned.
         */
		while (!(ptask = thread->taskList)) {
			pthread_cond_wait(&thread->taskListUpdated, &thread->taskListMutex);
		}

		next = ptask->nextScheduledTime;

		/* Wait for the time when task should be executed */
		waitState = pthread_cond_timedwait(&thread->taskListUpdated,
										   &thread->taskListMutex,
										   &next);

		/* Check why we stopped waiting */
		switch (waitState) {
		case 0:
			/*
			 * condition _taskListUpdated has been signaled, which means that
			 * a new task has been added or the previous head task has been
			 * deleted. So need to restart again to get the new task to work on
			 */
			break;
		case ETIMEDOUT:
			/*
			 * Nothing happened when we waited for the task to be executed
			 * so let's execute it now
			 *
			 * Fall through
			 */
		case EINVAL:
			/*
			 * The selected closest task has a next execution time in the past,
			 * which is just a normal case with a one-shot task.
			 */
			__periodicTask_execute(thread, ptask);
			break;
		default:
			log_warning("Periodic Task thread: pthread_cond_timedwait() "
						"returned unknown result: %d", waitState);
			break;
		}
	}

	/* Shouldn't reach here */
	return NULL;
}

static void thread_dispose(Task_Thread *thread)
{
	pthread_mutex_destroy(&thread->taskListMutex);
	pthread_cond_destroy(&thread->taskListUpdated);
	pthread_cond_destroy(&thread->taskExecuted);

	free(thread);
}

/*
 * A special task to tear down the entire worker thread
 * that executes it
 */
static void stopTask(void *arg)
{
	Task_Thread *thread = (Task_Thread *) arg;

	pthread_mutex_lock(&thread->taskListMutex);
	__periodicTask_deleteRecursive(thread->taskList);
	thread->taskList = NULL;
	pthread_mutex_unlock(&thread->taskListMutex);

	thread_dispose(thread);
	pthread_exit(NULL);
}

int ptask_schedule(Task_Thread *thread, periodic_task task,
				   void *arg, long period, int executeTimes)
{
	Periodic_Task *ptask;

	if ((executeTimes <= 0) && (executeTimes != EXECUTE_INDEFINITE)) {
		return -1;
	}

	pthread_mutex_lock(&(thread->taskListMutex));
	if (!(ptask = __periodicTask_create(thread, task, arg, period, executeTimes))) {
		pthread_mutex_unlock(&(thread->taskListMutex));
		return -1;
	}

	pthread_cond_signal(&(thread->taskListUpdated));
	pthread_mutex_unlock(&(thread->taskListMutex));

	/*
	 * Once the mutex is unlocked above, the worker thread may be scheduled
	 * in before this thread that inserts the stopTask. Consequently the whole
	 * worker thread along with the entire task list may have been destroyed,
	 * therefore the task descriptor of the stopTask should not be accessed
	 * to avoid invalid memory access
	 */
	return (task == stopTask) ? 1 : ptask->id;
}

int ptask_reschedule(Task_Thread *thread, int taskId,
					 long period, int executeTimes, int add)
{
	Periodic_Task *ptask;
	struct timespec addTime, temp;

	if (executeTimes == 0) {
		return -1;
	}

	pthread_mutex_lock(&thread->taskListMutex);
	if (!(ptask = __periodicTask_get(thread, taskId))) {
		pthread_mutex_unlock(&thread->taskListMutex);
		return -1;
	}

	if (add == 1) {
		/* add provided time to the period and next execution time */
		timespec_fromMillis(&addTime, period);
		timespec_copy(&temp, &ptask->period);

		if (timespec_add(&temp, &addTime) < 0) {
			pthread_mutex_unlock(&thread->taskListMutex);
			return -1;
		}

		timespec_copy(&ptask->period, &temp);
		timespec_add(&ptask->nextScheduledTime, &addTime);

		ptask->executeTimes = executeTimes;
	} else {
		/* reset period to the given new value */
		if (period < 0) {
			pthread_mutex_unlock(&thread->taskListMutex);
			return -1;
		}

		__periodicTask_setPeriod(ptask, period, executeTimes);
		__periodicTask_resetExecTime(thread, ptask, 0);
	}

	pthread_cond_signal(&thread->taskListUpdated);
	pthread_mutex_unlock(&thread->taskListMutex);
	return 0;
}

/*
 * Reset the next execution time based on current time
 * of the specified task
 */
int ptask_reset(Task_Thread *thread, int taskId)
{
	Periodic_Task *ptask;

	pthread_mutex_lock(&thread->taskListMutex);
	if (!(ptask = __periodicTask_get(thread, taskId))) {
		pthread_mutex_unlock(&thread->taskListMutex);
		return -1;
	}

	__periodicTask_resetExecTime(thread, ptask, 0);

	pthread_cond_signal(&thread->taskListUpdated);
	pthread_mutex_unlock(&thread->taskListMutex);

	return 0;
}

/*
 * Cancel(dequeue and free) the specified task from tasklist
 *
 * If the task is being executed, then whether to wait for
 * its completion will be decided by the wait parameter.
 *
 * NOTE: the wait parameter must be 0 under any of following
 * cases, otherwise deadlock emerges!
 * 1. when the caller is currently holding any mutex;
 * 2. the executed task is trying to cancel itself
 */
int ptask_cancel(Task_Thread *thread, int taskId, int wait)
{
	Periodic_Task *ptask;

	pthread_mutex_lock(&thread->taskListMutex);
	if (!(ptask = __periodicTask_get(thread, taskId))) {
		pthread_mutex_unlock(&thread->taskListMutex);
		return -1;
	}

	/*
	 * If some other thread has started deletion of this task,
	 * have THAT thread finish its job
	 */
	if (ptask->isCancelled == 1) {
		pthread_mutex_unlock(&(thread->taskListMutex));
		return 0;
	}

	ptask->isCancelled = 1;

	while (ptask->isExecuting == 1 && wait == 1) {
		pthread_cond_wait(&thread->taskExecuted, &thread->taskListMutex);
	}

	__periodicTask_removeFromList(thread, ptask);
	free(ptask);

	pthread_cond_signal(&thread->taskListUpdated);

	pthread_mutex_unlock(&thread->taskListMutex);
	return 0;
}

Task_Thread *ptask_init(void)
{
	Task_Thread *thread;

	if (!(thread = (Task_Thread *)malloc(sizeof(Task_Thread)))) {
		log_error("Failed to allocate a task thread");
		return NULL;
	}
	memset(thread, 0, sizeof(Task_Thread));

	thread->id_gen = 1;
	pthread_mutex_init(&thread->taskListMutex, NULL);
	pthread_cond_init(&thread->taskListUpdated, NULL);
	pthread_cond_init(&thread->taskExecuted, NULL);

	if (pthread_create(&thread->thread, NULL, &threadCycle, thread) != 0) {
		log_error("Unable to start a new thread");
		thread_dispose(thread);
		thread = NULL;
	}

	return thread;
}

int ptask_dispose(Task_Thread *thread, int wait)
{
	pthread_t saved;
	int error;

	if (!thread) {
		return -1;
	}

	/*
	 * Save a copy of the PID just in case the whole Task_Thread structure
	 * may have been released by the stopTask, which is the case when the
	 * worker thread is immediately scheduled once the mutex is unlocked in
	 * ptask_schedule.
	 */
	saved = thread->thread;

	if ((error = ptask_schedule(thread, stopTask, thread, 0, 1)) <= 0) {
		return error;
	}

	return (wait == 1) ? pthread_join(saved, NULL) : 0;
}

/*
 * Dequeue the specific task/job from the queue
 */
void obix_cancel_task(obix_task_t *task)
{
	if (task->initialised == 1 && task->t) {
		ptask_cancel(task->t, task->id, 1);
	}
}

int obix_schedule_task(obix_task_t *task)
{
	if (task->initialised == 0 || !task->t) {
		return -1;
	}

	task->id = ptask_schedule(task->t, task->func, task->args,
							  task->period, task->times);

	return (task->id < 0) ? -1 : 0;
}

/*
 * Add a special task to terminate and release the entire thread
 */
void obix_destroy_task(obix_task_t *task)
{
	if (task->initialised == 1 && task->t) {
		ptask_dispose(task->t, 1);
	}
}

/*
 * Reset the next execution time from the current moment on
 */
int obix_reset_task(obix_task_t *task)
{
	if (task->initialised == 0 || task->id < 0) {
		return -1;
	}

	return ptask_reset(task->t, task->id);
}

/*
 * Initialise a task descriptor, specifying its payload function and
 * other attributes such as argument, running period etc.
 *
 * Also create a worker thread if not provided. Callers can make use
 * of pointers of existing worker threads to run more than one task.
 */
int obix_setup_task(obix_task_t *task, Task_Thread *t, periodic_task func,
					void *args, long period, int times)
{
	if (task->initialised == 1) {
		return 0;
	}

	if (!t) {
		if (!(task->t = ptask_init())) {
			log_error("Failed to fork worker threads");
			return -1;
		}
	} else {
		task->t = t;
	}

	task->id = 0;		/* not scheduled yet */
	task->func = func;
	task->args = args;
	task->period = period;
	task->times = times;

	task->initialised = 1;
	return 0;
}
